# 框架与模块化

前端框架的设计与模块化思想深度绑定——模块化是框架实现**代码复用、逻辑拆分、工程化管理**的核心基础。不同框架基于自身设计理念，对模块化的实现方式、应用场景进行了针对性优化，既依赖通用的模块规范（如 ES Modules），又衍生出符合自身特性的模块化实践。

## 核心逻辑：框架为什么需要模块化？

前端框架的核心目标是构建复杂应用，而复杂应用的开发必须解决：

- 代码如何拆分（避免单文件臃肿）；
- 功能如何复用（如组件、逻辑、工具函数）；
- 依赖如何管理（避免命名冲突、明确依赖关系）。

模块化正是解决这些问题的核心方案。框架通过对“模块”的定义、组织、依赖管理进行封装，让开发者能以模块化方式高效开发。

## 主流框架的模块化实践对比

### 1. React：基于 JS 原生模块化的“组件优先”设计

React 的模块化理念更贴近 JavaScript 原生模块化的扩展，核心是**以“组件”为最小模块单元**，并深度依赖 ES Modules（`import`/`export`）实现模块化管理。

#### 核心模块化特性：

- **组件即模块**：每个组件（函数组件/类组件）都是独立模块，通过`import`引入依赖（如其他组件、工具函数），通过`export`暴露给外部使用。

  ```jsx
  // Button.jsx（组件模块）
  import { useState } from "react";
  export default function Button() {
    /* ... */
  }

  // Page.jsx（引入组件模块）
  import Button from "./Button";
  ```

- **逻辑复用的模块化**：

  - 早期通过“高阶组件（HOC）”实现逻辑复用（将逻辑封装为高阶函数模块，返回增强后的组件）；
  - 现代通过“自定义 Hooks”实现更轻量的逻辑模块化：将可复用逻辑（如表单处理、数据请求）封装为独立的 Hook 函数模块，通过`import`在任意组件中复用。

    ```jsx
    // useRequest.js（逻辑模块）
    export function useRequest(url) {
      const [data, setData] = useState(null);
      // 封装请求逻辑...
      return { data, loading };
    }

    // 组件中复用逻辑模块
    import { useRequest } from "./useRequest";
    function UserList() {
      const { data } = useRequest("/users");
    }
    ```

- **与 ES Modules 深度协同**：React 不强制自定义模块规范，完全基于 ES Modules 的静态特性（如`import`的静态分析），配合打包工具（如 Webpack、Vite）实现 Tree-shaking（摇树优化），剔除未使用的模块代码，减少打包体积。

### 2. Vue：“单文件组件”与“组合式逻辑”的模块化集成

Vue 对模块化的设计更偏向“集成化体验”，通过**单文件组件（SFC，.vue 文件）** 封装模块的完整能力，并在逻辑复用层提供更灵活的模块化方案。

#### 核心模块化特性：

- **单文件组件（SFC）：模块的“原子单元”**  
  .vue 文件本身就是一个独立模块，内部集成了模板（`template`）、逻辑（`script`）、样式（`style`），通过 ES Modules 与外部交互：

  ```vue
  <!-- Button.vue（SFC模块） -->
  <template><button>点击</button></template>
  <script>
    export default { props: ["text"] }; // 暴露组件模块
  </script>

  <!-- 引入组件模块 -->
  <script>
    import Button from "./Button.vue";
    export default { components: { Button } };
  </script>
  ```

- **逻辑复用的模块化升级**：

  - Vue 2 依赖“混入（mixin）”，但存在命名冲突、依赖不明确等问题；
  - Vue 3 通过“组合式 API（Composition API）”实现更优雅的逻辑模块化：将可复用逻辑封装为“组合式函数（Composables）”，本质是返回响应式数据的函数模块，通过`import`在组件中自由组合。

    ```js
    // useCounter.js（逻辑模块）
    import { ref } from "vue";
    export function useCounter() {
      const count = ref(0);
      const increment = () => count.value++;
      return { count, increment }; // 暴露响应式逻辑
    }

    // 组件中复用
    <script setup>
      import {useCounter} from './useCounter'; const {(count, increment)} =
      useCounter(); // 组合逻辑模块
    </script>;
    ```

- **与打包工具的协同**：Vue 的 SFC 需要通过`vue-loader`（Webpack）或`@vitejs/plugin-vue`（Vite）解析为 JS 模块，最终通过 ES Modules 被打包工具处理，支持 Tree-shaking（依赖 ES Modules 静态特性）。

### 3. Angular：“完整模块化体系”的强规范设计

Angular 是模块化设计最“彻底”的框架，它基于 TypeScript 构建了一套**独立的模块化规范（NgModule）**，将应用拆分为多个“功能模块”，每个模块明确管理自身的组件、服务、依赖。

#### 核心模块化特性：

- **NgModule：框架级模块单元**  
  Angular 的`@NgModule`装饰器定义一个模块，明确声明：

  - `declarations`：模块内部的组件、指令、管道（只能属于一个模块）；
  - `exports`：暴露给其他模块使用的组件/指令/管道；
  - `imports`：依赖的其他模块（如`CommonModule`提供`*ngFor`等基础指令）；
  - `providers`：模块内的服务（可被注入到组件中）。

  ```typescript
  // user.module.ts（用户模块）
  import { NgModule } from "@angular/core";
  import { UserComponent } from "./user.component";
  import { CommonModule } from "@angular/common"; // 依赖基础模块

  @NgModule({
    declarations: [UserComponent], // 内部组件
    exports: [UserComponent], // 暴露组件给外部
    imports: [CommonModule], // 引入依赖模块
  })
  export class UserModule {}
  ```

- **模块分层与依赖管理**：  
  Angular 推荐按功能拆分模块（如`CoreModule`、`SharedModule`、`FeatureModule`），通过严格的`imports`/`exports`控制依赖，避免全局污染。例如：

  - `CoreModule`：存放单例服务（如`AuthService`），仅在根模块导入一次；
  - `SharedModule`：存放通用组件（如`ButtonComponent`），通过`exports`共享给其他业务模块。

- **与 ES Modules 的关系**：Angular 的`NgModule`是框架层面的“逻辑模块”，其实现依赖 ES Modules（通过`import`/`export`管理文件级依赖），两者互补：ES Modules 解决文件间依赖，`NgModule`解决功能单元的组合与暴露。

## 框架模块化的共性与差异总结

| 维度                 | React                | Vue                          | Angular                            |
| -------------------- | -------------------- | ---------------------------- | ---------------------------------- |
| 核心模块单元         | 组件（.jsx/.tsx）    | 单文件组件（.vue）           | NgModule（功能模块）               |
| 与 ES Modules 的关系 | 深度依赖（原生扩展） | 依赖（SFC 需编译为 ES 模块） | 依赖（文件级依赖）+ 自定义模块规范 |
| 逻辑复用模块化       | 自定义 Hooks         | 组合式函数（Composables）    | 服务（Service）+ 模块共享          |
| 模块化规范灵活性     | 灵活（依赖 JS 原生） | 中等（SFC+ES Modules）       | 严格（自定义 NgModule 规范）       |

## 本质：框架通过模块化解决“复杂应用的可维护性”

无论哪种框架，模块化的核心目标一致：**将复杂应用拆分为可独立开发、测试、复用的单元**。差异仅在于“模块的定义方式”和“依赖管理的规范严格度”——React 偏向原生 JS 的灵活扩展，Vue 通过 SFC 提供集成化体验，Angular 则通过强规范确保大型团队协作的一致性。

在实际开发中，需结合框架特性设计模块结构（如 React 的组件+Hook 拆分、Vue 的 SFC+组合式函数、Angular 的 Core/Shared/Feature 模块分层），才能最大化模块化的价值。
