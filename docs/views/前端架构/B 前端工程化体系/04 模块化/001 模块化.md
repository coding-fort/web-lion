# 模块化

前端模块化是现代前端开发的基石，它通过将代码分割为独立、可复用的模块，解决了传统前端开发中代码组织混乱、依赖管理复杂等问题。以下从历史演进到主流规范，系统梳理前端模块化的核心知识点：

## 一、模块化发展历程

### 1. **全局变量时代**

- **问题**：  
  所有代码共享全局作用域，变量/函数命名冲突频发，代码难以维护。
- **示例**：
  ```html
  <script src="module1.js"></script>
  <script src="module2.js"></script>
  <script>
    // module1.js 定义
    var data = "hello";

    // module2.js 定义
    function data() {
      /* ... */
    } // 命名冲突！
  </script>
  ```

### 2. **命名空间模式**

- **解决方案**：  
  将代码封装在一个全局对象中，减少命名冲突。
- **示例**：

  ```javascript
  // module1.js
  var MyApp = {
    data: "hello",
    sayHello: function () {
      /* ... */
    },
  };

  // module2.js
  var MyApp = MyApp || {};
  MyApp.utils = {
    formatDate: function () {
      /* ... */
    },
  };
  ```

### 3. **立即执行函数表达式（IIFE）**

- **解决方案**：  
  使用闭包创建独立作用域，避免污染全局。
- **示例**：
  ```javascript
  // module.js
  (function () {
    var privateData = "secret"; // 私有变量

    function privateMethod() {
      /* ... */
    } // 私有方法

    window.MyModule = {
      publicMethod: function () {
        /* ... */
      }, // 公开方法
    };
  })();
  ```

## 二、主流模块化规范

### 1. **CommonJS（服务器端）**

- **适用场景**：Node.js 服务器端环境。
- **特点**：
  - 同步加载模块（符合服务器端特性）。
  - 使用 `require()` 导入模块，`module.exports` 导出模块。
- **示例**：

  ```javascript
  // math.js
  const add = (a, b) => a + b;
  module.exports = { add };

  // main.js
  const math = require("./math.js");
  console.log(math.add(1, 2)); // 3
  ```

### 2. **AMD（Asynchronous Module Definition，浏览器端）**

- **适用场景**：浏览器端，需异步加载模块。
- **特点**：
  - 异步加载模块，避免阻塞浏览器渲染。
  - 使用 `define()` 定义模块，`require()` 加载模块。
  - 代表实现：RequireJS。
- **示例**：

  ```javascript
  // math.js
  define(function () {
    const add = (a, b) => a + b;
    return { add };
  });

  // main.js
  require(["math"], function (math) {
    console.log(math.add(1, 2)); // 3
  });
  ```

### 3. **CMD（Common Module Definition，浏览器端）**

- **适用场景**：浏览器端，延迟执行。
- **特点**：
  - 按需加载，延迟执行（与 AMD 立即执行不同）。
  - 代表实现：SeaJS。
- **示例**：

  ```javascript
  // math.js
  define(function (require, exports, module) {
    const add = (a, b) => a + b;
    exports.add = add;
  });

  // main.js
  define(function (require, exports, module) {
    const math = require("./math");
    // 只有在需要时才执行 math 模块
  });
  ```

### 4. **ES Modules（ES6+ 标准）**

- **适用场景**：现代浏览器和 Node.js（需配置）。
- **特点**：
  - 静态导入/导出，编译时确定依赖关系。
  - 支持 Tree-shaking（移除未使用的代码）。
  - 浏览器通过 `<script type="module">` 支持。
- **示例**：

  ```javascript
  // math.js
  export const add = (a, b) => a + b;

  // main.js
  import { add } from "./math.js";
  console.log(add(1, 2)); // 3
  ```

## 三、ES Modules 核心特性

### 1. **静态导入与导出**

```javascript
// 命名导出（多个）
export const name = "John";
export function greet() {
  /* ... */
}

// 或统一导出
const age = 30;
function sayHi() {
  /* ... */
}
export { age, sayHi };

// 默认导出（仅一个）
export default function () {
  /* ... */
}

// 导入
import defaultExport, { name, greet } from "./module.js";
```

### 2. **动态导入（Dynamic Import）**

```javascript
// 按需加载模块（返回 Promise）
async function loadModule() {
  const module = await import("./module.js");
  module.doSomething();
}

// 条件加载
if (condition) {
  import("./feature.js").then((feature) => {
    feature.init();
  });
}
```

### 3. **模块加载行为**

- **浏览器加载**：

  ```html
  <script type="module" src="main.js"></script>
  ```

  - 默认使用 `defer` 特性（延迟执行，按顺序加载）。
  - 模块路径必须是完整路径（如 `./module.js`，不能省略 `.js`）。

- **Node.js 支持**：

  ```javascript
  // package.json 中添加
  {
    "type": "module"
  }

  // 或使用 .mjs 扩展名
  ```

## 四、模块打包工具

### 1. **Webpack**

- **特点**：
  - 支持多种模块规范（CommonJS、ES Modules、AMD 等）。
  - 通过 Loader 处理各种资源（CSS、图片、字体等）。
  - 提供代码分割、懒加载等优化功能。
- **示例配置**：
  ```javascript
  // webpack.config.js
  module.exports = {
    entry: "./src/index.js",
    output: {
      filename: "bundle.js",
      path: path.resolve(__dirname, "dist"),
    },
    module: {
      rules: [{ test: /\.js$/, use: "babel-loader" }],
    },
  };
  ```

### 2. **Vite**

- **特点**：
  - 基于原生 ES Modules，开发环境无需打包，启动速度极快。
  - 生产环境使用 Rollup 打包，输出优化后的代码。
- **示例配置**：

  ```javascript
  // vite.config.js
  import { defineConfig } from "vite";

  export default defineConfig({
    plugins: [react()],
    resolve: {
      alias: {
        "@": "/src",
      },
    },
  });
  ```

### 3. **Rollup**

- **特点**：
  - 专注于 ES Modules 打包，生成更简洁的代码。
  - 适合开发库（如 React、Vue 等都使用 Rollup 打包）。
- **示例配置**：

  ```javascript
  // rollup.config.js
  import { nodeResolve } from "@rollup/plugin-node-resolve";
  import commonjs from "@rollup/plugin-commonjs";

  export default {
    input: "src/index.js",
    output: {
      file: "dist/bundle.js",
      format: "es",
    },
    plugins: [nodeResolve(), commonjs()],
  };
  ```

## 五、模块化实践技巧

### 1. **Tree-shaking 最佳实践**

- 使用 ES Modules 语法（避免 CommonJS 的 `require`）。
- 在 `package.json` 中标记 `sideEffects: false`（若无副作用）。
- 使用支持 Tree-shaking 的打包工具（如 Webpack、Rollup）。

### 2. **循环依赖处理**

- **问题场景**：模块 A 依赖模块 B，同时模块 B 依赖模块 A。
- **解决方案**：
  - 重构代码，提取公共逻辑到第三方模块。
  - 动态导入（在需要时再导入）。
  ```javascript
  // moduleA.js
  let moduleB;
  function doSomething() {
    if (!moduleB) {
      moduleB = require("./moduleB");
    }
    // 使用 moduleB
  }
  ```

### 3. **跨环境兼容**

- **通用模块定义（UMD）**：
  ```javascript
  (function (root, factory) {
    if (typeof define === "function" && define.amd) {
      // AMD
      define(["dependency"], factory);
    } else if (typeof module === "object" && module.exports) {
      // CommonJS
      module.exports = factory(require("dependency"));
    } else {
      // 全局变量
      root.MyModule = factory(root.Dependency);
    }
  })(this, function (Dependency) {
    // 模块实现
    return {
      /* ... */
    };
  });
  ```

## 六、常见问题与解决方案

1. **浏览器不支持 ES Modules**：

   - 使用 Babel 转译为 CommonJS 或 UMD 格式。
   - 使用 Webpack/Vite 等打包工具生成兼容代码。

2. **模块加载性能问题**：

   - 使用动态导入实现按需加载。
   - 通过 `preload/prefetch` 优化加载顺序。

3. **模块版本冲突**：

   - 使用包管理器（如 npm、yarn）的锁定文件（package-lock.json、yarn.lock）。
   - 通过 Webpack 的 `resolve.alias` 强制使用特定版本。

4. **服务端与浏览器差异**：
   - 使用 isomorphic/universal 库（如 isomorphic-fetch）。
   - 在服务端使用 `process.browser` 等环境变量判断运行环境。

## 七、总结

模块化是现代前端开发的核心思想，从早期的 IIFE 到如今的 ES Modules，规范不断演进，工具日益完善。掌握模块化的核心概念（静态导入/导出、动态加载）和主流工具（Webpack、Vite），能帮助开发者构建更清晰、更易维护、性能更优的前端应用。
