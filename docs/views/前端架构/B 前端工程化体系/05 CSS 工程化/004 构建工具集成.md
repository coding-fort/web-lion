# 构建工具集成

CSS 构建工具集成是现代前端工程化的核心环节，通过将预处理（如 Sass）、后处理（如 PostCSS）、压缩优化等工具串联，形成高效的样式处理流水线。以下从主流构建工具出发，系统解析 CSS 集成方案：

## 一、Webpack 集成方案

Webpack 是最成熟的 CSS 构建工具，通过 Loader 实现全链路处理。

### 核心 Loaders

1. **style-loader**  
   将 CSS 注入到 DOM 中（开发环境）。

   ```javascript
   {
     test: /\.css$/,
     use: ['style-loader']
   }
   ```

2. **css-loader**  
   解析 CSS 中的 `@import` 和 `url()`，支持 CSS Modules。

   ```javascript
   {
     test: /\.css$/,
     use: [
       'style-loader',
       {
         loader: 'css-loader',
         options: {
           modules: {
             localIdentName: '[name]__[local]--[hash:base64:5]'
           }
         }
       }
     ]
   }
   ```

3. **sass-loader**  
   编译 SCSS/Sass 文件（依赖 Dart Sass 或 Node Sass）。

   ```javascript
   {
     test: /\.scss$/,
     use: ['style-loader', 'css-loader', 'sass-loader']
   }
   ```

4. **postcss-loader**  
   集成 PostCSS 插件（如 Autoprefixer、CSSNano）。
   ```javascript
   {
     test: /\.css$/,
     use: [
       'style-loader',
       'css-loader',
       {
         loader: 'postcss-loader',
         options: {
           postcssOptions: {
             plugins: [
               require('autoprefixer'),
               require('cssnano')
             ]
           }
         }
       }
     ]
   }
   ```

### 典型配置示例

```javascript
// webpack.config.js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");

module.exports = {
  module: {
    rules: [
      // 处理 CSS
      {
        test: /\.css$/,
        use: [
          process.env.NODE_ENV === "production"
            ? MiniCssExtractPlugin.loader // 生产环境提取 CSS
            : "style-loader", // 开发环境注入 DOM
          "css-loader",
          "postcss-loader",
        ],
      },
      // 处理 SCSS
      {
        test: /\.scss$/,
        use: ["style-loader", "css-loader", "postcss-loader", "sass-loader"],
      },
    ],
  },
  plugins: [
    // 提取 CSS 到单独文件
    new MiniCssExtractPlugin({
      filename: "[name].[contenthash].css",
    }),
  ],
  optimization: {
    // 压缩 CSS
    minimizer: [new CssMinimizerPlugin()],
  },
};
```

## 二、Vite 集成方案

Vite 基于原生 ES Modules 构建，对 CSS 处理更高效。

### 原生支持特性

1. **CSS 导入**

   ```javascript
   import "./style.css"; // 直接导入 CSS
   ```

2. **CSS Modules**  
   通过 `.module.css` 文件名自动启用：

   ```javascript
   import styles from "./style.module.css";
   console.log(styles.className); // 哈希类名
   ```

3. **预处理器支持**  
   内置支持 SCSS、Less、Stylus，只需安装相应依赖：
   ```bash
   npm install sass
   ```
   ```css
   /* style.scss */
   $primary: #3498db;
   .button {
     color: $primary;
   }
   ```

### PostCSS 配置

通过 `vite.config.js` 配置 PostCSS：

```javascript
// vite.config.js
export default {
  css: {
    postcss: {
      plugins: [
        require("autoprefixer"),
        require("cssnano")({
          preset: "default",
        }),
      ],
    },
  },
};
```

### 处理静态资源

Vite 自动处理 CSS 中的资源引用（如图片、字体）：

```css
/* style.css */
.logo {
  background-image: url("./logo.png"); /* 自动处理路径 */
}
```

## 三、Rollup 集成方案

Rollup 专注于库打包，CSS 处理需插件支持。

### 核心插件

1. **@rollup/plugin-postcss**  
   处理 CSS、SCSS，支持提取、压缩：

   ```javascript
   import postcss from "@rollup/plugin-postcss";

   export default {
     plugins: [
       postcss({
         extract: true, // 提取 CSS
         minimize: true, // 压缩
         plugins: [require("autoprefixer")],
       }),
     ],
   };
   ```

2. **rollup-plugin-sass**  
   编译 SCSS/Sass：

   ```javascript
   import sass from "rollup-plugin-sass";

   export default {
     plugins: [
       sass({
         insert: true, // 注入 DOM
       }),
     ],
   };
   ```

### 典型配置示例

```javascript
// rollup.config.js
import postcss from "@rollup/plugin-postcss";
import autoprefixer from "autoprefixer";
import cssnano from "cssnano";

export default {
  input: "src/index.js",
  output: {
    file: "dist/bundle.js",
    format: "es",
  },
  plugins: [
    postcss({
      extract: "styles.css", // 提取到单独文件
      plugins: [autoprefixer(), cssnano()],
      minimize: true,
    }),
  ],
};
```

## 四、Gulp 集成方案

Gulp 通过流处理实现 CSS 构建。

### 核心插件

1. **gulp-sass**  
   编译 SCSS/Sass：

   ```javascript
   const sass = require("gulp-sass")(require("sass"));

   gulp.task("sass", () => {
     return gulp
       .src("src/scss/*.scss")
       .pipe(sass().on("error", sass.logError))
       .pipe(gulp.dest("dist/css"));
   });
   ```

2. **gulp-postcss**  
   集成 PostCSS 插件：

   ```javascript
   const postcss = require("gulp-postcss");
   const autoprefixer = require("autoprefixer");
   const cssnano = require("cssnano");

   gulp.task("css", () => {
     return gulp
       .src("src/css/*.css")
       .pipe(postcss([autoprefixer(), cssnano()]))
       .pipe(gulp.dest("dist/css"));
   });
   ```

3. **gulp-clean-css**  
   压缩 CSS：

   ```javascript
   const cleanCSS = require("gulp-clean-css");

   gulp.task("minify-css", () => {
     return gulp
       .src("src/css/*.css")
       .pipe(cleanCSS())
       .pipe(gulp.dest("dist/css"));
   });
   ```

### 典型工作流

```javascript
// gulpfile.js
const { src, dest, series, watch } = require("gulp");
const sass = require("gulp-sass")(require("sass"));
const postcss = require("gulp-postcss");
const autoprefixer = require("autoprefixer");
const cssnano = require("cssnano");
const sourcemaps = require("gulp-sourcemaps");

// 编译 SCSS
function compileSass() {
  return src("src/scss/main.scss")
    .pipe(sourcemaps.init())
    .pipe(sass().on("error", sass.logError))
    .pipe(postcss([autoprefixer(), cssnano()]))
    .pipe(sourcemaps.write("."))
    .pipe(dest("dist/css"));
}

// 监听文件变化
function watchFiles() {
  watch("src/scss/**/*.scss", compileSass);
}

exports.default = series(compileSass, watchFiles);
```

## 五、最佳实践

### 1. **环境区分配置**

- **开发环境**：
  - 使用 `style-loader` 注入 CSS，支持热更新。
  - 启用 sourcemap，方便调试。
- **生产环境**：
  - 提取 CSS 到单独文件（如 `MiniCssExtractPlugin`）。
  - 压缩优化（如 CSSNano、PurgeCSS）。

### 2. **性能优化策略**

1. **CSS 压缩**：  
   使用 CSSNano 或 clean-css 压缩代码。
2. **Tree-shaking**：  
   通过 PurgeCSS 移除未使用的 CSS：
   ```javascript
   // webpack 配置
   new PurgeCSSPlugin({
     paths: glob.sync(`${PATHS.src}/**/*`, { nodir: true }),
   });
   ```
3. **缓存控制**：  
   使用 `[contenthash]` 命名 CSS 文件，支持长期缓存。

### 3. **兼容性处理**

- 通过 `browserslist` 统一目标浏览器范围：
  ```json
  // package.json
  {
    "browserslist": ["last 2 versions", "ie >= 11"]
  }
  ```
- 使用 Autoprefixer 添加浏览器前缀。

### 4. **预处理器与后处理器结合**

处理流程通常为：

```
SCSS/Sass → CSS → PostCSS（添加前缀、压缩） → 输出
```

对应 Loader/插件链：

```javascript
sass-loader → css-loader → postcss-loader
```

## 六、未来趋势

### 1. **构建工具一体化**

工具链进一步整合（如 Vite 统一开发与构建流程），减少配置复杂度。

### 2. **原生 CSS 特性增强**

CSS 容器查询、逻辑属性等特性普及，减少对预处理工具的依赖。

### 3. **WebAssembly 加速**

通过 WASM 提升 Sass 编译、PostCSS 处理等环节的性能。

## 总结

不同构建工具的 CSS 集成方案各有特点：

- **Webpack**：功能全面，适合复杂项目，配置灵活但复杂。
- **Vite**：快速启动，开发体验优秀，对 CSS 原生支持友好。
- **Rollup**：专注库打包，CSS 处理简洁高效。
- **Gulp**：基于流处理，适合定制化工作流。

实际项目中，建议根据需求选择工具，优先考虑 Vite（开发体验）或 Webpack（功能全面），并通过合理配置实现预处理、后处理、压缩优化的完整流程。
