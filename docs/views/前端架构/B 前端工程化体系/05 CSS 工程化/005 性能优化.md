# 性能优化

CSS 模块化性能优化是现代前端工程化的关键环节，通过减少样式文件体积、优化加载顺序、避免运行时计算等方式，提升页面加载速度和运行效率。以下从关键指标到具体技术，系统解析优化策略：

## 一、核心性能指标

### 1. **CSS 文件体积**

- 过大的 CSS 文件会增加下载时间，影响首屏加载。
- **优化目标**：压缩后单文件不超过 100KB（移动端建议更小）。

### 2. **样式计算时间**

- 浏览器解析 CSS 并计算元素样式的耗时。
- **优化目标**：单帧样式计算时间 < 16ms（60fps）。

### 3. **重排（Reflow）与重绘（Repaint）**

- 频繁修改样式触发重排/重绘，导致页面卡顿。
- **优化目标**：减少重排次数，批量处理样式修改。

## 二、文件体积优化

### 1. **压缩与最小化**

- **工具**：CSSNano、clean-css、Terser（Webpack 集成）。
- **配置示例（Webpack）**：

  ```javascript
  const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");

  module.exports = {
    optimization: {
      minimizer: [new CssMinimizerPlugin()],
    },
  };
  ```

- **效果**：典型项目 CSS 体积减少 40-60%。

### 2. **移除未使用的 CSS（Tree-shaking）**

- **工具**：PurgeCSS、UnCSS。
- **配置示例（Webpack）**：

  ```javascript
  const PurgeCSSPlugin = require("purgecss-webpack-plugin");
  const glob = require("glob-all");

  module.exports = {
    plugins: [
      new PurgeCSSPlugin({
        paths: glob.sync(`${PATHS.src}/**/*`, { nodir: true }),
      }),
    ],
  };
  ```

- **注意事项**：
  - 动态生成的类（如 `className={isActive ? 'active' : 'inactive'}`）需特殊处理。
  - 通过 `safelist` 保留必要样式（如第三方库样式）。

### 3. **CSS 分割与按需加载**

- **策略**：
  - 按路由分割 CSS（如 React.lazy/Suspense）。
  - 关键 CSS 内联到 HTML（首屏优化）。
- **工具**：Webpack 的 `MiniCssExtractPlugin`、Vite 的 `cssCodeSplit`。
- **示例（Webpack）**：
  ```javascript
  new MiniCssExtractPlugin({
    filename: "[name].[contenthash].css",
    chunkFilename: "[id].[contenthash].css", // 按需加载的 CSS
  });
  ```

## 三、加载性能优化

### 1. **关键 CSS 内联**

- 将首屏必需的 CSS 直接嵌入 HTML，减少 HTTP 请求。
- **工具**：`html-inline-css-webpack-plugin`。
- **配置示例**：
  ```javascript
  new HtmlInlineCssWebpackPlugin({
    filter: (fileName) => fileName.includes("critical"),
  });
  ```
- **效果**：减少 1 个 HTTP 请求，提升 LCP（Largest Contentful Paint）。

### 2. **预加载（Preload）与预取（Prefetch）**

- **预加载**：

  ```html
  <link
    rel="preload"
    href="styles.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  ```

  优先加载关键 CSS，提升 FCP（First Contentful Paint）。

- **预取**：
  ```html
  <link rel="prefetch" href="secondary.css" as="style" />
  ```
  空闲时加载非关键 CSS，提升后续页面加载速度。

### 3. **HTTP/2 与服务器推送**

- **HTTP/2 多路复用**：并行加载多个 CSS 文件。
- **服务器推送**：服务器主动推送 CSS 资源。
- **配置示例（Express）**：
  ```javascript
  app.get("/", (req, res) => {
    res.push("/styles.css", {
      request: { accept: "*/*" },
      response: { "content-type": "text/css" },
    });
    res.send(html);
  });
  ```

## 四、运行时性能优化

### 1. **减少样式复杂度**

- **避免深层嵌套选择器**（如 `body div ul li a`）。
- **推荐使用 BEM 或 CSS Modules**：

  ```css
  /* BEM */
  .header__nav-link {
    /* ... */
  }

  /* CSS Modules */
  .navLink__3x4y5 {
    /* ... */
  }
  ```

- **效果**：浏览器样式匹配速度提升 20-30%。

### 2. **避免频繁修改样式**

- **反例**：
  ```javascript
  element.style.width = "100px";
  element.style.height = "200px"; // 触发两次重排
  ```
- **优化**：

  ```javascript
  // 批量修改样式
  element.classList.add("expanded");

  // 或使用 CSSOM
  const style = window.getComputedStyle(element);
  ```

### 3. **CSS-in-JS 性能优化**

- **使用编译时生成 CSS**（如 `@vanilla-extract/css`）：

  ```javascript
  // 编译时生成 CSS
  import { style } from "@vanilla-extract/css";

  const className = style({
    color: "red",
  });
  ```

- **避免运行时计算样式**（如动态生成 CSS）。

## 五、工具链优化

### 1. **Sass 编译性能提升**

- **使用 Dart Sass**（比 Node Sass 快 2-4 倍）。
- **配置缓存**：
  ```javascript
  // Webpack 配置
  {
    test: /\.scss$/,
    use: [
      'style-loader',
      'css-loader',
      {
        loader: 'sass-loader',
        options: {
          implementation: require('sass'),
          sassOptions: {
            cache: true
          }
        }
      }
    ]
  }
  ```

### 2. **PostCSS 插件优化**

- **按需使用插件**：

  ```javascript
  // postcss.config.js
  const plugins = [];

  if (process.env.NODE_ENV === "production") {
    plugins.push(require("cssnano"));
  }

  module.exports = { plugins };
  ```

- **使用 WASM 版本插件**（如 `cssnano-wasm`）提升性能。

### 3. **Vite 与 CSS 处理**

- **优势**：
  - 基于 ESBuild 预构建依赖，CSS 处理更快。
  - 原生支持 CSS Modules 和预处理器。
- **配置示例**：
  ```javascript
  // vite.config.js
  export default {
    css: {
      modules: {
        localsConvention: "camelCaseOnly",
      },
      preprocessorOptions: {
        scss: {
          additionalData: `@import "./src/variables.scss";`,
        },
      },
    },
  };
  ```

## 六、监控与分析

### 1. **性能分析工具**

- **Chrome DevTools**：
  - **Coverage 面板**：分析未使用的 CSS。
  - **Performance 面板**：检测样式计算瓶颈。
- **Lighthouse**：评估 CSS 相关指标（如 FCP、LCP）。

### 2. **自定义监控指标**

- 在关键节点记录性能：
  ```javascript
  console.time("style-calculation");
  // 执行样式修改
  console.timeEnd("style-calculation");
  ```
- 使用 `PerformanceObserver` 监听重排/重绘：
  ```javascript
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      console.log("Layout shift:", entry);
    });
  });
  observer.observe({ type: "layout-shift", buffered: true });
  ```

## 七、未来趋势

### 1. **CSS 原生性能增强**

- **容器查询**：减少媒体查询嵌套，提升响应式布局性能。
- **CSS 逻辑属性**：简化布局代码，减少样式复杂度。

### 2. **WebAssembly 加速**

- Sass 编译、CSS 压缩等任务通过 WASM 实现 10-100 倍性能提升。

### 3. **AI 驱动的优化**

- AI 自动分析 CSS 使用情况，推荐 Tree-shaking 策略和样式结构优化方案。

## 总结

CSS 模块化性能优化需从**文件体积、加载顺序、运行时效率**三个维度入手，结合工具链（Webpack/Vite）和最佳实践（Tree-shaking、关键 CSS 内联）实现全方位提升。在实际项目中，建议通过 Lighthouse 等工具建立基线指标，优先优化影响最大的环节（如首屏 CSS 体积、样式计算复杂度），并持续监控性能变化。
