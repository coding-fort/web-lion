# 规范与最佳实践

CSS 模块化规范与最佳实践是构建可维护、高性能前端项目的关键。通过系统化的命名约定、文件组织和工具链集成，可有效解决传统 CSS 的全局作用域、命名冲突和可维护性问题。以下从规范设计到落地实践，提供完整指南：

## 一、命名规范

### 1. **BEM（Block-Element-Modifier）**

- **结构**：`block__element--modifier`
- **示例**：
  ```css
  .card {
    /* 块 */
  }
  .card__title {
    /* 元素 */
  }
  .card--featured {
    /* 修饰符 */
  }
  ```
- **优势**：
  - 明确的层级关系，避免嵌套过深。
  - 全局唯一性，减少命名冲突。
- **局限**：
  - 命名冗长，需遵循严格规范。

### 2. **OOCSS（Object-Oriented CSS）**

- **核心原则**：
  - 分离结构与皮肤（如 `.btn` 定义结构，`.btn-primary` 定义样式）。
  - 分离容器与内容（如 `.container` 不依赖特定子元素）。
- **示例**：
  ```css
  /* 结构 */
  .btn {
    padding: 8px 16px;
  }
  /* 皮肤 */
  .btn-primary {
    background-color: blue;
  }
  ```

### 3. **SMACSS（Scalable and Modular Architecture for CSS）**

- **分类**：
  - Base：基础样式（如 `body`、`a`）。
  - Layout：布局样式（如 `.header`、`.footer`）。
  - Module：组件样式（如 `.card`、`.nav`）。
  - State：状态样式（如 `.is-active`、`.is-hidden`）。
  - Theme：主题样式（如 `.theme-dark`）。
- **文件组织**：
  ```
  styles/
    base/
      reset.css
      typography.css
    layout/
      grid.css
      header.css
    modules/
      buttons.css
      cards.css
    states/
      states.css
    themes/
      dark-theme.css
  ```

## 二、文件组织规范

### 1. **按组件组织**

```
components/
  Button/
    Button.jsx
    Button.module.css  // 组件样式
    Button.test.js     // 测试文件
  Card/
    Card.jsx
    Card.module.css
    Card.test.js
```

- **优势**：
  - 样式与组件强绑定，便于维护。
  - 支持按需加载（如通过 Webpack 动态导入）。

### 2. **按功能/类型组织**

```
styles/
  base/         // 基础样式
    reset.css
    typography.css
  components/   // 组件样式
    buttons.css
    cards.css
  layout/       // 布局样式
    header.css
    footer.css
  utils/        // 工具类
    animations.css
    utilities.css
```

- **优势**：
  - 清晰的功能划分，适合大型项目。
  - 便于样式复用和共享。

### 3. **混合组织方式**

```
src/
  components/
    Button/
      index.jsx
      styles.css        // 组件特定样式
  styles/
    global.css          // 全局样式
    variables.module.css // 全局变量（CSS Modules）
    themes/
      dark-theme.css    // 主题样式
```

- **适用场景**：  
  中大型项目，平衡组件内聚性与全局样式管理。

## 三、CSS 模块化最佳实践

### 1. **CSS Modules 实践**

- **启用配置**：
  ```javascript
  // webpack.config.js
  {
    test: /\.module\.css$/,
    use: [
      'style-loader',
      {
        loader: 'css-loader',
        options: {
          modules: {
            localIdentName: '[name]__[local]--[hash:base64:5]'
          }
        }
      }
    ]
  }
  ```
- **使用技巧**：

  ```jsx
  import styles from "./Button.module.css";

  // 组合类名
  <button className={[styles.button, isActive && styles.active].join(" ")}>
    Click
  </button>;

  // 全局类名
  <div className={`global-class ${styles.localClass}`}></div>;
  ```

### 2. **CSS-in-JS 实践**

- **选择方案**：
  - 编译时方案（如 Linaria）：性能优先。
  - 运行时方案（如 styled-components）：动态样式需求。
- **优化技巧**：
  ```jsx
  // 缓存动态样式，避免重复生成
  const useDynamicStyle = (isActive) => {
    return css`
      color: ${isActive ? "red" : "blue"};
    `;
  };
  ```

### 3. **原生 CSS 特性实践**

- **CSS 变量**：

  ```css
  :root {
    --primary-color: #3498db;
    --spacing: 16px;
  }

  .button {
    background-color: var(--primary-color);
    padding: var(--spacing);
  }
  ```

- **CSS 嵌套**：
  ```css
  .card {
    &__title {
      font-size: 1.2rem;
    }
    &:hover {
      transform: scale(1.05);
    }
  }
  ```

### 4. **工具链集成实践**

- **PostCSS 配置**：
  ```javascript
  // postcss.config.js
  module.exports = {
    plugins: [
      require("autoprefixer"), // 添加浏览器前缀
      require("cssnano"), // 压缩 CSS
      require("postcss-preset-env"), // 转换现代 CSS 特性
    ],
  };
  ```
- **Tree-shaking**：  
  使用 PurgeCSS 移除未使用的 CSS：
  ```javascript
  // webpack.config.js
  new PurgeCSSPlugin({
    paths: glob.sync(`${PATHS.src}/**/*`, { nodir: true }),
    safelist: {
      standard: [/^active$/, /^open$/], // 保留特定类名
      deep: [/^modal-/, /^toast-/], // 保留包含特定前缀的类名
    },
  });
  ```

## 四、性能优化实践

### 1. **CSS 文件体积优化**

- **压缩与最小化**：  
  使用 CSSNano 或 clean-css 压缩 CSS 文件。
- **按需加载**：  
  通过动态导入加载非关键 CSS：
  ```javascript
  import("./specific-page.css").then(() => {
    // 样式加载完成后执行
  });
  ```

### 2. **运行时性能优化**

- **避免内联样式**：

  ```jsx
  // 反例
  <div style={{ color: 'red', fontSize: '16px' }}>Text</div>

  // 优化
  .error { color: red; font-size: 1rem; }
  <div className="error">Text</div>
  ```

- **批量修改样式**：
  ```javascript
  // 避免多次触发重排
  element.classList.add("expanded", "highlighted");
  ```

### 3. **缓存与预加载**

- **缓存策略**：  
  使用 `[contenthash]` 命名 CSS 文件，支持长期缓存：
  ```javascript
  // webpack.config.js
  new MiniCssExtractPlugin({
    filename: "[name].[contenthash].css",
  });
  ```
- **预加载关键 CSS**：
  ```html
  <link rel="preload" href="critical.css" as="style" />
  ```

## 五、可维护性提升实践

### 1. **样式复用策略**

- **CSS 变量**：
  ```css
  :root {
    --color-primary: #3498db;
    --font-heading: "Inter", sans-serif;
  }
  ```
- **Mixin 与函数**：

  ```scss
  // SCSS mixin
  @mixin button-style($color) {
    background-color: $color;
    border-radius: 4px;
    padding: 8px 16px;
  }

  .primary-button {
    @include button-style(#3498db);
  }
  ```

### 2. **文档与注释**

- **CSS 文档工具**：  
  使用 `sassdoc` 或 `cssdoc` 生成样式文档：
  ```css
  /**
   * Button component
   * @param {String} $color - Button color
   * @param {String} $size - Button size (small, medium, large)
   */
  @mixin button($color, $size) {
    /* ... */
  }
  ```
- **注释规范**：
  ```css
  /* 模块级注释 */
  .card {
    /* 功能注释 */
    display: flex;
    /* 兼容性注释 */
    -webkit-overflow-scrolling: touch; /* iOS 滚动优化 */
  }
  ```

### 3. **团队协作规范**

- **样式指南**：  
  制定团队样式指南，明确命名规则、文件结构、变量使用等：
  ```markdown
  # CSS 规范

  1. 使用 BEM 命名法
  2. 避免内联样式
  3. 优先使用 CSS 变量
  4. ...
  ```
- **代码审查**：  
  在 PR 中检查样式代码是否符合规范，避免全局样式滥用。

## 六、未来趋势

### 1. **CSS 原生模块化增强**

- CSS 模块（CSS Modules Level 1）标准化后，可能替代工具链方案。
- 容器查询（Container Queries）和逻辑属性（Logical Properties）简化响应式设计。

### 2. **AI 辅助样式开发**

- AI 工具自动生成符合 BEM 规范的类名和样式结构。
- 智能分析样式依赖关系，优化 Tree-shaking 策略。

### 3. **WebAssembly 加速**

- 通过 WASM 提升 Sass 编译、PostCSS 处理等任务的性能。

## 总结

CSS 模块化规范与最佳实践的核心目标是**提升代码可维护性、减少命名冲突、优化性能**。通过采用 BEM 等命名规范、合理组织文件结构、结合 CSS Modules/CSS-in-JS 等技术方案，并辅以性能优化和团队协作机制，可构建高效、可扩展的样式系统。在未来，随着 CSS 原生能力增强和 AI 工具普及，CSS 模块化将变得更加自动化和智能化。
