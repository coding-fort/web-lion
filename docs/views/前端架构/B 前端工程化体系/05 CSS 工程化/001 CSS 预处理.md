# CSS 预处理

CSS 预处理是前端开发中提升样式代码可维护性、复用性和扩展性的重要手段。通过引入变量、嵌套、混合（Mixin）等编程特性，预处理语言（如 Sass、Less、Stylus）让 CSS 具备了更强的逻辑性和工程化能力。以下从核心特性到最佳实践，系统梳理 CSS 预处理的关键知识点：

## 一、主流预处理语言对比

| 特性         | Sass (SCSS)                       | Less                    | Stylus                   |
| ------------ | --------------------------------- | ----------------------- | ------------------------ |
| **语法风格** | 兼容 CSS（SCSS）+ 缩进式（Sass）  | 类 CSS 语法             | 灵活（可省略括号、分号） |
| **变量**     | `$variable: value`                | `@variable: value`      | `variable = value`       |
| **嵌套**     | 支持（通过 `&` 引用父选择器）     | 支持                    | 支持                     |
| **Mixin**    | `@mixin` + `@include`             | `.mixin()` + `.mixin()` | `mixin() { ... }`        |
| **函数**     | 内置丰富（如 `darken()`）         | 基础函数                | 自定义函数灵活           |
| **生态系统** | 最成熟（Rails、Webpack 原生支持） | 中等（依赖 Node.js）    | 较小众                   |
| **编译速度** | 较慢（Ruby 实现，后改为 Dart）    | 快（JavaScript 实现）   | 快（JavaScript 实现）    |

## 二、核心特性详解

### 1. **变量（Variables）**

- **作用**：存储重复使用的值（如颜色、间距、字体），统一管理样式常量。
- **示例（SCSS）**：

  ```scss
  // 定义变量
  $primary-color: #3498db;
  $base-spacing: 16px;

  // 使用变量
  .button {
    background-color: $primary-color;
    padding: $base-spacing / 2;
  }
  ```

- **优势**：修改一处即可全局生效，避免魔法值（如直接使用 `#3498db`）。

### 2. **嵌套（Nesting）**

- **作用**：通过层级结构组织选择器，减少重复，提升可读性。
- **示例（SCSS）**：

  ```scss
  .nav {
    background-color: #f8f9fa;

    ul {
      list-style: none;
      margin: 0;
    }

    li {
      padding: 8px;

      &:hover {
        // 父选择器引用
        background-color: #e9ecef;
      }
    }
  }
  ```

- **编译后 CSS**：
  ```css
  .nav {
    background-color: #f8f9fa;
  }
  .nav ul {
    list-style: none;
    margin: 0;
  }
  .nav li {
    padding: 8px;
  }
  .nav li:hover {
    background-color: #e9ecef;
  }
  ```

### 3. **混合（Mixins）**

- **作用**：封装可复用的样式片段，支持参数传递，类似函数。
- **示例（SCSS）**：

  ```scss
  // 定义带参数的 mixin
  @mixin border-radius($radius: 4px) {
    -webkit-border-radius: $radius;
    -moz-border-radius: $radius;
    border-radius: $radius;
  }

  // 使用 mixin
  .card {
    @include border-radius(8px);
  }

  .button {
    @include border-radius; // 使用默认值
  }
  ```

- **优势**：减少重复代码，尤其适用于处理浏览器前缀、复杂样式组合。

### 4. **继承（Extend）**

- **作用**：让选择器继承另一个选择器的所有样式。
- **示例（SCSS）**：

  ```scss
  .btn {
    padding: 8px 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .btn-primary {
    @extend .btn;
    background-color: #3498db;
    color: white;
  }
  ```

- **编译后 CSS**：

  ```css
  .btn,
  .btn-primary {
    padding: 8px 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .btn-primary {
    background-color: #3498db;
    color: white;
  }
  ```

- **注意**：与 Mixin 相比，Extend 生成的 CSS 更简洁（合并选择器），但依赖关系更紧密。

### 5. **函数（Functions）**

- **作用**：处理计算、转换，内置多种实用函数（如颜色操作、单位转换）。
- **示例（SCSS）**：

  ```scss
  $base-color: #3498db;

  .button {
    background-color: $base-color;
    border-color: darken($base-color, 10%); // 颜色加深
    width: percentage(3/4); // 转换为百分比
  }
  ```

- **常用函数**：
  - 颜色：`lighten()`、`darken()`、`saturate()`、`rgba()`
  - 数学：`ceil()`、`floor()`、`round()`
  - 字符串：`unquote()`、`quote()`

### 6. **导入（Import）**

- **作用**：将多个样式文件合并为一个，组织大型项目的样式结构。
- **示例（SCSS）**：
  ```scss
  // main.scss
  @import "variables"; // 导入变量文件
  @import "components/buttons"; // 导入组件样式
  @import "components/cards";
  ```
- **优势**：避免 CSS 文件碎片化，通过 `_partial.scss`（下划线开头）定义无需单独编译的局部文件。

## 三、最佳实践

### 1. **项目结构组织**

```
styles/
  ├── abstracts/    # 抽象工具（变量、函数、mixin）
  │   ├── _variables.scss
  │   ├── _functions.scss
  │   └── _mixins.scss
  ├── base/         # 基础样式（重置、全局设置）
  │   ├── _reset.scss
  │   └── _typography.scss
  ├── components/   # 组件样式（按钮、卡片等）
  │   ├── _buttons.scss
  │   ├── _cards.scss
  │   └── _forms.scss
  ├── layout/       # 布局样式（导航、页脚等）
  │   ├── _header.scss
  │   ├── _footer.scss
  │   └── _grid.scss
  └── main.scss     # 主入口文件
```

### 2. **性能优化**

- **避免深层嵌套**：限制嵌套深度（建议不超过 3 层），防止生成过于复杂的选择器。
- **按需导入**：仅导入实际使用的 mixin/变量，避免冗余代码。
- **使用编译缓存**：通过工具（如 Webpack 的 `cache-loader`）缓存已编译的 SCSS，提升构建速度。

### 3. **与现代工具集成**

- **Webpack**：通过 `sass-loader` 处理 SCSS 文件，支持热更新。
- **PostCSS**：编译后通过 PostCSS 添加浏览器前缀（如 `autoprefixer`）。
- **CSS Modules**：结合 CSS Modules 解决全局命名冲突问题。

### 4. **迁移策略（CSS → SCSS）**

1. **渐进式迁移**：先将现有 CSS 文件重命名为 `.scss`，逐步引入变量、mixin 等特性。
2. **提取公共样式**：将重复的样式（如颜色、间距）转换为变量或 mixin。
3. **模块化拆分**：按组件/功能拆分大型 CSS 文件，通过 `@import` 组织。

## 四、常见问题与解决方案

### 1. **编译性能问题**

- **问题**：大型项目 SCSS 编译耗时过长。
- **解决方案**：
  - 使用 Dart Sass（性能优于 Ruby Sass）。
  - 结合 Vite/Webpack 的缓存机制。
  - 拆分样式文件，避免单个文件过大。

### 2. **全局命名冲突**

- **问题**：不同组件的类名重复导致样式覆盖。
- **解决方案**：
  - 使用 BEM 命名规范（如 `.block__element--modifier`）。
  - 结合 CSS Modules 或 CSS-in-JS（如 styled-components）。

### 3. **与 CSS 新特性的平衡**

- **问题**：CSS 原生支持变量、嵌套等特性（如 CSS Variables），是否还需预处理？
- **决策参考**：
  - **选择预处理**：需要复杂逻辑（如循环、条件判断）、浏览器兼容性处理、成熟的工具生态。
  - **选择原生 CSS**：项目简单、仅需基础变量/嵌套、追求零编译成本。

## 五、未来趋势

### 1. **与 CSS 新特性融合**

- 原生 CSS 变量（Custom Properties）与 SCSS 变量共存，前者用于运行时动态修改，后者用于编译时静态计算。
- CSS 嵌套规则（CSS Nesting Module）逐渐普及，可能减少对预处理嵌套的依赖。

### 2. **工具链智能化**

- AI 辅助生成 mixin/函数，例如根据设计稿自动提取颜色变量和响应式断点。
- 编译工具（如 Sass）支持更细粒度的增量编译，提升开发体验。

### 3. **与 Web Components 结合**

- 将 SCSS 与 Shadow DOM 结合，实现组件级样式封装，同时保留预处理的强大功能。

## 总结

CSS 预处理通过引入编程特性，显著提升了样式代码的可维护性和开发效率。在选择预处理语言时，建议优先考虑 Sass（SCSS），因其生态成熟、功能全面；对于简单项目或已深度集成 Node.js 的场景，Less 也是不错的选择。未来，预处理语言将与 CSS 原生特性（如变量、嵌套）深度融合，形成更强大的样式工程化体系。
