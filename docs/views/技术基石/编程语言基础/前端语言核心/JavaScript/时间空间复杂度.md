# 时间空间复杂度

在 JavaScript 中，**时间复杂度**和**空间复杂度**的分析方式与其他编程语言（如 Python、Java 等）一致，因为它们描述的是算法本身的效率，而不是具体语言的实现细节。以下是详细解释：

## **时间复杂度**

时间复杂度衡量算法运行时间随输入规模增长的趋势。常见表示法为大 O 符号（如 `O(n)`、`O(n^2)`）。

### **示例分析**

假设我们有一个合并两个有序数组的算法（类似前面的双指针法）：

```javascript
function merge(nums1, m, nums2, n) {
  let i = m - 1,
    j = n - 1,
    k = m + n - 1;
  while (i >= 0 && j >= 0) {
    nums1[k--] = nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];
  }
  while (j >= 0) {
    nums1[k--] = nums2[j--];
  }
}
```

- **时间复杂度**：`O(m + n)`
  - 每个元素最多被比较和赋值一次，总操作次数为 `m + n`。
  - 与语言无关，无论用 JavaScript 还是其他语言，时间复杂度都是线性的。

## **空间复杂度**

空间复杂度衡量算法运行过程中额外占用的内存空间随输入规模增长的趋势。

### **示例分析**

对于上述合并算法：

- **空间复杂度**：`O(1)`
  - 只使用了固定数量的额外变量（`i`, `j`, `k`），不随输入规模 `m` 和 `n` 变化。
  - 直接在原数组 `nums1` 上修改，没有创建新数组。

## **JavaScript 中的特殊注意事项**

虽然时间/空间复杂度的理论分析是通用的，但在实际编码时需要注意 JavaScript 的特性：

### 1. **数组的动态性**

JavaScript 的数组是动态的，但题目中明确要求合并到 `nums1` 中，且 `nums1` 的长度已预留了足够的空间（尾部有 `n` 个 `0`）。因此不需要调整数组长度，直接覆盖即可。

### 2. **函数参数传递**

JavaScript 中数组是按引用传递的，直接修改 `nums1` 会影响原始数组，这符合题目要求。

### 3. **边界条件**

需要处理 `m = 0` 或 `n = 0` 的情况，例如：

```javascript
if (n === 0) return; // 无需合并
```

## **常见操作的时间复杂度**

以下是 JavaScript 中常见操作的时间复杂度参考：

| **操作**          | **时间复杂度** | **示例**                       |
| ----------------- | -------------- | ------------------------------ |
| 数组尾部插入/删除 | `O(1)`         | `arr.push()`, `arr.pop()`      |
| 数组头部插入/删除 | `O(n)`         | `arr.unshift()`, `arr.shift()` |
| 数组遍历          | `O(n)`         | `for (let i = 0; i < n; i++)`  |
| 数组排序          | `O(n log n)`   | `arr.sort()`                   |

## **总结**

- **时间复杂度**：描述算法执行时间与输入规模的关系，与语言无关。
- **空间复杂度**：描述算法额外内存占用与输入规模的关系，与语言无关。
- 在 JavaScript 中，合并两个有序数组的最优解法时间复杂度为 `O(m + n)`，空间复杂度为 `O(1)`，与其他语言一致。


vue, vue-router, vuex, axios, element-ui, less