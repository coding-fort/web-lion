# 移动端适配

## 一、基础篇：移动端适配的核心认知（零基础入门）

首先要理解移动端适配的本质——**让同一套代码在不同尺寸、不同分辨率的移动设备上，视觉和交互体验保持一致**。

### 1. 核心问题（新手先搞懂）

移动端开发会遇到 3 个核心适配难题，也是我们适配的目标：

- **屏幕尺寸不一致**：从 4 英寸小屏手机到 7 英寸平板，宽度/高度差异大；
- **像素密度（DPR）不同**：比如 iPhone 的 Retina 屏，1 个 CSS 像素对应多个物理像素；
- **视口（Viewport）混乱**：手机浏览器默认会用“桌面视口”（980px）渲染，导致页面缩小。

### 2. 基础准备：设置视口（第一步必做）

视口是浏览器渲染页面的区域，必须先通过`<meta>`标签设置移动端视口，否则所有适配都是空谈。

**核心代码（复制即用）**：

```html
<!-- 移动端视口核心配置，放在<head>里 -->
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>
```

**参数解释（新手易懂版）**：

- `width=device-width`：视口宽度等于设备屏幕宽度；
- `initial-scale=1.0`：初始缩放比例为 1（不缩放）；
- `maximum-scale=1.0`：禁止用户放大页面；
- `user-scalable=no`：禁止用户手动缩放（可选，根据产品需求）。

### 3. 像素基础（理解 DPR）

- **CSS 像素**：我们写代码用的`px`，是逻辑像素，比如`width: 100px`；
- **物理像素**：屏幕实际的像素点，比如 iPhone 14 的物理分辨率是 2532×1170；
- **DPR（设备像素比）**：`DPR = 物理像素 / CSS像素`，比如 iPhone 14 的 DPR=3，意味着 1 个 CSS 像素对应 3 个物理像素。

**新手避坑**：不用纠结 DPR 的具体数值，现代 CSS/框架会自动处理，只需知道“设置视口后，CSS 的 1px 就是设备的 1 个逻辑像素”。

## 二、入门篇：基础适配方法（新手首选）

掌握视口后，学习 3 种最基础的适配方法，满足 80%的简单移动端页面需求。

### 1. 百分比适配

利用`%`相对单位，让元素宽度/高度随父容器/屏幕变化，新手最易上手。

**示例代码**：

```css
/* 页面容器占满屏幕宽度，最大宽度限制（避免大屏拉伸） */
.container {
  width: 100%;
  max-width: 750px; /* 设计稿宽度，比如750px */
  margin: 0 auto; /* 居中 */
  padding: 0 15px; /* 左右留白，避免内容贴边 */
}
/* 按钮宽度占容器80%，适配不同屏幕 */
.btn {
  width: 80%;
  height: 44px; /* 固定高度，移动端常用44px（易点击） */
  font-size: 16px;
}
/* 两列布局，各占50% */
.col-left,
.col-right {
  width: 50%;
  float: left;
  padding: 10px;
  box-sizing: border-box; /* 关键：padding不影响宽度计算 */
}
```

**核心要点**：

- 必须加`box-sizing: border-box`，否则`padding`/`border`会让元素宽度超出预期；
- 用`max-width`限制最大宽度，避免平板/大屏手机上内容过宽。

### 2. Media Query（媒体查询）

针对不同屏幕宽度，设置不同样式，是响应式布局的基础。

**示例代码**：

```css
/* 基础样式（默认适配小屏） */
body {
  font-size: 14px;
}
.container {
  padding: 0 10px;
}

/* 适配宽度≥375px的设备（如iPhone 8/11） */
@media (min-width: 375px) {
  body {
    font-size: 15px;
  }
  .container {
    padding: 0 15px;
  }
}

/* 适配宽度≥414px的设备（如iPhone 14 Plus） */
@media (min-width: 414px) {
  body {
    font-size: 16px;
  }
  .container {
    padding: 0 20px;
  }
}

/* 适配平板（宽度≥768px） */
@media (min-width: 768px) {
  .container {
    max-width: 750px;
    padding: 0 30px;
  }
}
```

**核心要点**：

- 遵循“移动优先”原则：先写小屏样式，再用`min-width`适配大屏；
- 常用断点：320px（小屏）、375px（主流）、414px（大屏手机）、768px（平板）。

### 3. rem 基础适配

利用`rem`相对根元素字号的特性，实现全局样式适配，比百分比更易统一。

**示例代码**：

```css
/* 根元素基准字号（以750px设计稿为例，1rem=100px，方便计算） */
html {
  font-size: 100px;
}
/* 设计稿上30px的字号，对应0.3rem */
body {
  font-size: 0.3rem;
}
/* 设计稿上700px的宽度，对应7rem */
.container {
  width: 7rem;
  margin: 0 auto;
  padding: 0 0.15rem;
}
/* 设计稿上44px的按钮高度，对应0.44rem */
.btn {
  height: 0.44rem;
  font-size: 0.32rem;
}
```

**核心要点**：

- 设计稿宽度通常为 750px，设置`html {font-size: 100px}`，则设计稿上的`1px = 0.01rem`，计算方便；
- 新手可先固定根字号，后续进阶再动态修改。

## 三、进阶篇：主流适配方案（企业级开发）

掌握基础后，学习 2 种大厂常用的进阶方案，解决“精准适配所有设备”的问题。

### 1. rem + JS 动态适配（最主流）

核心逻辑：通过 JS 动态计算根元素的`font-size`，让`1rem`在不同屏幕上对应不同的 CSS 像素，完美适配设计稿。

**完整代码（复制即用）**：

```html
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rem动态适配</title>
    <style>
      /* 初始化样式 */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      /* 动态根字号由JS设置，这里写基础样式 */
      .container {
        width: 7.5rem; /* 对应750px设计稿的100%宽度 */
        margin: 0 auto;
        padding: 0 0.2rem; /* 对应设计稿20px */
      }
      .title {
        font-size: 0.36rem; /* 对应设计稿36px */
        margin: 0.3rem 0; /* 对应设计稿30px */
      }
      .btn {
        width: 6rem; /* 对应设计稿600px */
        height: 0.88rem; /* 对应设计稿88px */
        font-size: 0.32rem; /* 对应设计稿32px */
        background: #007aff;
        color: #fff;
        border: none;
        border-radius: 0.1rem; /* 对应设计稿10px */
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="title">rem动态适配示例</h1>
      <button class="btn">点击按钮</button>
    </div>

    <script>
      // 核心JS：动态计算根字号
      (function setRem() {
        // 1. 设计稿宽度（通常750px，根据实际调整）
        const designWidth = 750;
        // 2. 基准值（1rem对应设计稿100px，方便计算）
        const baseSize = 100;
        // 3. 获取设备实际宽度
        const deviceWidth = document.documentElement.clientWidth;
        // 4. 计算根字号：(设备宽度/设计稿宽度) × 基准值
        const fontSize = (deviceWidth / designWidth) * baseSize;
        // 5. 设置根元素font-size
        document.documentElement.style.fontSize = fontSize + "px";
        // 6. 窗口大小变化时重新计算（如旋转屏幕）
        window.addEventListener("resize", setRem);
      })();
    </script>
  </body>
</html>
```

**核心要点**：

- 计算逻辑：`根字号 = (设备宽度 / 设计稿宽度) × 基准值`；
- 设计稿上的像素值 ÷ 100 = rem 值（如设计稿 36px = 0.36rem）；
- 优点：适配精准，一套代码适配所有设备；
- 缺点：依赖 JS，若 JS 加载失败，样式会错乱（可加兜底样式）。

### 2. vw 适配（无 JS，更简洁）

利用`vw`（视口宽度 1%）直接适配，无需 JS，是现代移动端适配的优选方案。

**核心逻辑**：
设计稿宽度 750px → 1vw = 750px / 100 = 7.5px → 设计稿像素值 ÷ 7.5 = vw 值。

**示例代码**：

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
/* 设计稿750px → 1vw = 7.5px */
.container {
  width: 100vw; /* 占满屏幕宽度 */
  max-width: 750px; /* 限制最大宽度 */
  margin: 0 auto;
  padding: 0 calc(20 / 7.5) vw; /* 20px → 20/7.5 ≈ 2.666vw */
}
.title {
  font-size: calc(36 / 7.5) vw; /* 36px → 4.8vw */
  margin: calc(30 / 7.5) vw 0; /* 30px → 4vw */
}
.btn {
  width: calc(600 / 7.5) vw; /* 600px → 80vw */
  height: calc(88 / 7.5) vw; /* 88px → 11.733vw */
  font-size: calc(32 / 7.5) vw; /* 32px → 4.266vw */
  background: #007aff;
  color: #fff;
  border: none;
  border-radius: calc(10 / 7.5) vw; /* 10px → 1.333vw */
}
```

**优化技巧（SCSS/LESS）**：
用预处理器定义函数，简化计算（无需手动除 7.5）：

```scss
// SCSS函数：设计稿px转vw
@function px2vw($px) {
  $design-width: 750; // 设计稿宽度
  @return ($px / $design-width) * 100vw;
}

// 使用
.container {
  padding: 0 px2vw(20); // 等价于calc(20/7.5)vw
}
.title {
  font-size: px2vw(36); // 等价于calc(36/7.5)vw
}
```

**核心要点**：

- 优点：无需 JS，原生 CSS 实现，更稳定；
- 缺点：计算稍繁琐（可通过预处理器优化）；
- 适用场景：现代移动端项目，无需兼容老旧设备。

## 四、实战篇：适配避坑与最佳实践（进阶重点）

### 1. 常见坑点及解决方案

| 坑点             | 表现                                                   | 解决方案                                                                                                                                    |
| ---------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| 1px 边框变粗     | Retina 屏上 1px CSS 像素对应多个物理像素，边框看起来粗 | 用伪元素+transform 缩放：`border: none; ::after { content: ''; width: 200%; height: 200%; border: 1px solid #000; transform: scale(0.5); }` |
| 横向滚动条       | 元素宽度设 100vw，包含滚动条宽度                       | 改用`width: 100%`，或给 body 加`overflow-x: hidden`                                                                                         |
| vh 适配高度异常  | 移动端键盘弹出时，vh 值突变                            | 改用`min-height: 100vh`，或结合 JS 监听窗口高度变化                                                                                         |
| 字体大小适配异常 | 不同设备字体显示不一致                                 | 字号用`rem/vw`，并设置`min-font-size: 12px`避免过小                                                                                         |

### 2. 最佳实践（企业级标准）

1. **移动优先**：先写小屏样式，再用媒体查询适配大屏；
2. **单位组合**：
   - 布局宽度：`rem/vw`；
   - 边框/阴影：`px`（精准）；
   - 字号：`rem/vw`（适配）；
   - 间距：`rem/vw`（统一）；
3. **限制最大宽度**：给容器加`max-width: 750px`，避免大屏手机/平板上内容过宽；
4. **图片适配**：用`img { max-width: 100%; height: auto; }`，避免图片溢出；
5. **点击区域**：移动端按钮高度 ≥44px，避免点击不精准；
6. **兼容处理**：给老旧设备加兜底样式，如`html { font-size: 16px !important; }`。

## 五、高阶篇：框架适配（Vue/React）

现代前端框架可通过插件简化适配，无需手动写 JS/计算：

### 1. Vue 项目（使用 postcss-px-to-viewport）

```bash
# 安装依赖
npm install postcss-px-to-viewport --save-dev
```

```js
// postcss.config.js 配置
module.exports = {
  plugins: {
    "postcss-px-to-viewport": {
      viewportWidth: 750, // 设计稿宽度
      unitPrecision: 5, // 精度
      viewportUnit: "vw", // 转换后的单位
      selectorBlackList: [], // 不需要转换的选择器
      minPixelValue: 1, // 最小转换像素值
      mediaQuery: false, // 是否转换媒体查询中的px
    },
  },
};
```

**效果**：写`width: 750px`，自动转换为`width: 100vw`，无需手动计算。

### 2. React 项目（使用 px2rem-loader）

```bash
# 安装依赖
npm install px2rem-loader lib-flexible --save
```

```js
// webpack.config.js 配置
module: {
  rules: [
    {
      test: /\.css$/,
      use: [
        "style-loader",
        "css-loader",
        {
          loader: "px2rem-loader",
          options: {
            remUnit: 75, // 设计稿宽度750px → 750/10=75
          },
        },
      ],
    },
  ];
}
```

```js
// 入口文件引入lib-flexible
import "lib-flexible";
```

**效果**：自动动态设置根字号，写`px`自动转换为`rem`。

## 总结

1. **基础层**：先设置视口（核心），用百分比/媒体查询实现基础适配；
2. **进阶层**：掌握`rem + JS`（主流）和`vw`（现代）两种核心适配方案，解决精准适配问题；
3. **实战层**：避开 1px 边框、横向滚动等坑，遵循移动优先、单位组合等最佳实践；
4. **高阶层**：利用框架插件（postcss-px-to-viewport/lib-flexible）简化适配，提升开发效率。

掌握这套从基础到进阶的适配体系，你就能应对所有移动端适配场景，写出适配性强、易维护的移动端代码。
